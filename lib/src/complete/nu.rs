use heck::ToSnakeCase;

use crate::complete::CompleteOptions;

pub fn complete_nu(opts: &CompleteOptions) -> String {
    let usage_bin = &opts.usage_bin;
    let bin = &opts.bin;
    let bin_snake = bin.to_snake_case();
    let spec_variable = if let Some(cache_key) = &opts.cache_key {
        format!("_usage_spec_{bin_snake}_{}", cache_key.to_snake_case())
    } else {
        format!("_usage_spec_{bin_snake}")
    };

    let generated_comment = if let Some(source_file) = &opts.source_file {
        format!("# @generated by usage-cli from {source_file}")
    } else {
        "# @generated by usage-cli from usage spec".to_string()
    };
    let mut out = vec![
        generated_comment,
        format!("module _{bin_snake}_completions {{"),
    ];

    if let Some(spec) = &opts.spec {
        out.push(format!("    const {spec_variable} = r#'{spec}'#"));
    }

    // Build logic to write spec directly to file without storing in shell variables
    let file_write_logic = if let Some(usage_cmd) = &opts.usage_cmd {
        if opts.cache_key.is_some() {
            format!(
                r#"if not ($spec_file | path exists) {{
            {usage_cmd} | collect | save $spec_file
        }}"#
            )
        } else {
            format!(r#"{usage_cmd} | collect | save -f $spec_file"#)
        }
    } else if let Some(_spec) = &opts.spec {
        if opts.cache_key.is_some() {
            format!(
                r#"if not ($spec_file | path exists) {{
            ${spec_variable} | save $spec_file
        }}"#
            )
        } else {
            format!(r#"${spec_variable} | save -f $spec_file"#)
        }
    } else {
        String::new()
    };

    out.push(
        format!(
            r#"    def {bin_snake}_completer [spans: list<string>] {{
        let spec_file = $"($nu.temp-dir)/usage_{spec_variable}.spec"
        {file_write_logic}

        ({usage_bin} complete-word -f $spec_file --shell nu -- ...$spans)
        | lines
        | each {{|it| $it | split column "\t" | rename value description | into record }}
    }}

    @complete {bin_snake}_completer
    export extern {bin} []
}}
"#
        )
        .trim()
        .to_string(),
    );

    out.push(format!(
        r#"
# if "{usage_bin}" is not installed show an error
if (which {usage_bin} | is-empty) {{
    return (error make {{
        msg: "Error: {usage_bin} CLI not found. This is required for completions to work in {bin}.",
        help: "See https://usage.jdx.dev for more information." 
    }})
}}
use _{bin_snake}_completions *"#
    ));

    out.join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test::SPEC_KITCHEN_SINK;
    use insta::assert_snapshot;

    #[test]
    fn test_complete_nu() {
        assert_snapshot!(complete_nu(&CompleteOptions {
            usage_bin: "usage".to_string(),
            shell: "nu".to_string(),
            bin: "mycli".to_string(),
            cache_key: None,
            spec: None,
            usage_cmd: Some("mycli complete --usage".to_string()),
            include_bash_completion_lib: false,
            source_file: None,
        }));
        assert_snapshot!(complete_nu(&CompleteOptions {
            usage_bin: "usage".to_string(),
            shell: "nu".to_string(),
            bin: "mycli".to_string(),
            cache_key: Some("1.2.3".to_string()),
            spec: None,
            usage_cmd: Some("mycli complete --usage".to_string()),
            include_bash_completion_lib: false,
            source_file: None,
        }));
        assert_snapshot!(complete_nu(&CompleteOptions {
            usage_bin: "usage".to_string(),
            shell: "nu".to_string(),
            bin: "mycli".to_string(),
            cache_key: None,
            spec: Some(SPEC_KITCHEN_SINK.clone()),
            usage_cmd: None,
            include_bash_completion_lib: false,
            source_file: None,
        }));
    }
}
