use crate::complete::CompleteOptions;
use heck::ToSnakeCase;

pub fn complete_powershell(opts: &CompleteOptions) -> String {
    let usage_bin = &opts.usage_bin;
    let bin = &opts.bin;
    let bin_snake = bin.to_snake_case();
    let spec_variable = if let Some(cache_key) = &opts.cache_key {
        format!("_usage_spec_{bin_snake}_{}", cache_key.to_snake_case())
    } else {
        format!("_usage_spec_{bin_snake}")
    };
    let generated_comment = if let Some(source_file) = &opts.source_file {
        format!("# @generated by usage-cli from {source_file}")
    } else {
        "# @generated by usage-cli from usage spec".to_string()
    };

    // Build logic to write spec to file
    let file_write_logic = if let Some(usage_cmd) = &opts.usage_cmd {
        if opts.cache_key.is_some() {
            format!(
                r#"if (-not (Test-Path $specFile)) {{
    {usage_cmd} | Out-File -FilePath $specFile -Encoding utf8
}}"#
            )
        } else {
            format!(r#"{usage_cmd} | Out-File -FilePath $specFile -Encoding utf8"#)
        }
    } else if let Some(spec) = &opts.spec {
        // Use regular single-quoted string with doubled single quotes for escaping.
        // Here-strings (@'...'@) can't be used because '@ at line start terminates them.
        let spec_escaped = spec.to_string().replace("'", "''");
        if opts.cache_key.is_some() {
            format!(
                r#"if (-not (Test-Path $specFile)) {{
    '{spec_escaped}' | Out-File -FilePath $specFile -Encoding utf8
}}"#
            )
        } else {
            format!(r#"'{spec_escaped}' | Out-File -FilePath $specFile -Encoding utf8"#)
        }
    } else {
        String::new()
    };

    format!(
        r#"{generated_comment}

if (-not (Get-Command '{usage_bin}' -ErrorAction SilentlyContinue)) {{
    Write-Warning "Error: {usage_bin} CLI not found. This is required for completions to work in {bin}."
    Write-Warning "See https://usage.jdx.dev for more information."
    return
}}

Register-ArgumentCompleter -Native -CommandName '{bin}' -ScriptBlock {{
    param($wordToComplete, $commandAst, $cursorPosition)

    $tmpDir = if ($env:TEMP) {{ $env:TEMP }} else {{ [System.IO.Path]::GetTempPath() }}
    $specFile = Join-Path $tmpDir "usage_{spec_variable}.kdl"

    {file_write_logic}

    $words = $commandAst.CommandElements | ForEach-Object {{ $_.ToString() }}
    if ($words.Count -lt 1) {{
        $words = @('{bin}')
    }}

    $completions = & '{usage_bin}' complete-word --shell powershell -f "$specFile" -- @words $wordToComplete 2>$null

    if ($completions) {{
        $completions | ForEach-Object {{
            $parts = $_ -split "`t", 2
            $completion = $parts[0]
            $description = if ($parts.Count -gt 1) {{ $parts[1] }} else {{ '' }}

            [System.Management.Automation.CompletionResult]::new(
                $completion,
                $completion,
                'ParameterValue',
                $description
            )
        }}
    }}
}}"#
    )
    .trim()
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test::SPEC_KITCHEN_SINK;
    use insta::assert_snapshot;

    #[test]
    fn test_complete_powershell() {
        assert_snapshot!(complete_powershell(&CompleteOptions {
            usage_bin: "usage".to_string(),
            shell: "powershell".to_string(),
            bin: "mycli".to_string(),
            cache_key: None,
            spec: None,
            usage_cmd: Some("mycli complete --usage".to_string()),
            include_bash_completion_lib: false,
            source_file: None,
        }));
        assert_snapshot!(complete_powershell(&CompleteOptions {
            usage_bin: "usage".to_string(),
            shell: "powershell".to_string(),
            bin: "mycli".to_string(),
            cache_key: Some("1.2.3".to_string()),
            spec: None,
            usage_cmd: Some("mycli complete --usage".to_string()),
            include_bash_completion_lib: false,
            source_file: None,
        }));
        assert_snapshot!(complete_powershell(&CompleteOptions {
            usage_bin: "usage".to_string(),
            shell: "powershell".to_string(),
            bin: "mycli".to_string(),
            cache_key: None,
            spec: Some(SPEC_KITCHEN_SINK.clone()),
            usage_cmd: None,
            include_bash_completion_lib: false,
            source_file: None,
        }));
    }
}
